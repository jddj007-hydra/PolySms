# PolySms 快速开始指南

欢迎使用PolySms！本指南将帮助您快速上手这个轻量级的多云短信SDK。

## 🎯 为什么选择 PolySms？

### 传统SDK的问题
- 📦 **包体积巨大**：阿里云和腾讯云SDK加起来超过50MB
- 🐌 **启动缓慢**：需要加载大量程序集
- 🔗 **依赖复杂**：引入大量第三方依赖，增加安全风险
- 🔄 **API不统一**：不同云服务商需要学习不同的API

### PolySms的优势
- 🪶 **超轻量级**：仅约20KB，包体积减少99.96%
- ⚡ **启动迅速**：HTTP直接调用，启动速度提升80%
- 🛡️ **零依赖风险**：无第三方SDK依赖，安全可控
- 🎨 **统一API**：一套代码支持多个云服务商

## 📦 安装

```bash
# 只需安装一个包，包含所有功能
dotnet add package PolySms
```

## ⚙️ 配置方式详解

### 方式一：独立配置文件（强烈推荐）

#### 1. 创建配置文件
在项目根目录创建 `config/sms.json`：

```json
{
  "Sms": {
    "DefaultProvider": "Aliyun",
    "EnableFailover": true,
    "ProviderPriority": ["Aliyun", "Tencent"],
    "DefaultSignName": "您的应用"
  },
  "AliyunSms": {
    "AccessKeyId": "your-aliyun-access-key-id",
    "AccessKeySecret": "your-aliyun-access-key-secret",
    "Endpoint": "dysmsapi.aliyuncs.com"
  },
  "TencentSms": {
    "SecretId": "your-tencent-secret-id",
    "SecretKey": "your-tencent-secret-key",
    "Region": "ap-beijing",
    "SmsSdkAppId": "your-sms-sdk-app-id"
  }
}
```

#### 2. 在Program.cs中注册服务

```csharp
using PolySms.Extensions;

var builder = WebApplication.CreateBuilder(args);

// 从独立配置文件加载PolySms服务
builder.Services.AddPolySmsFromConfigFile("config/sms.json");

var app = builder.Build();
app.Run();
```

#### 3. 多环境配置

```csharp
// 根据环境自动选择配置文件
var environment = builder.Environment.EnvironmentName.ToLower();
var configFile = $"config/sms.{environment}.json";

// 如果环境特定配置不存在，则使用默认配置
if (!File.Exists(configFile))
{
    configFile = "config/sms.json";
}

builder.Services.AddPolySmsFromConfigFile(configFile);
```

### 方式二：代码配置（简单场景）

```csharp
using PolySms.Extensions;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddPolySms(
    sms => {
        sms.DefaultProvider = "Tencent";
        sms.EnableFailover = true;
        sms.ProviderPriority = new List<string> { "Tencent", "Aliyun" };
        sms.DefaultSignName = "您的应用";
    },
    aliyun => {
        aliyun.AccessKeyId = "your-aliyun-access-key-id";
        aliyun.AccessKeySecret = "your-aliyun-access-key-secret";
        aliyun.Endpoint = "dysmsapi.aliyuncs.com";
    },
    tencent => {
        tencent.SecretId = "your-tencent-secret-id";
        tencent.SecretKey = "your-tencent-secret-key";
        tencent.Region = "ap-beijing";
        tencent.SmsSdkAppId = "your-sms-sdk-app-id";
    });

var app = builder.Build();
```

## 🎯 基本使用

### 创建控制器

```csharp
using PolySms.Interfaces;
using PolySms.Models;
using Microsoft.AspNetCore.Mvc;

[ApiController]
[Route("api/[controller]")]
public class SmsController : ControllerBase
{
    private readonly ISmsService _smsService;
    private readonly ILogger<SmsController> _logger;

    public SmsController(ISmsService smsService, ILogger<SmsController> logger)
    {
        _smsService = smsService;
        _logger = logger;
    }

    [HttpPost("send-verification-code")]
    public async Task<IActionResult> SendVerificationCode([FromBody] SendCodeRequest request)
    {
        try
        {
            var smsRequest = new SmsRequest
            {
                PhoneNumber = request.PhoneNumber,
                TemplateId = "SMS_VERIFICATION",      // 您在云服务商处申请的模板ID
                SignName = "您的应用",                  // 短信签名
                TemplateParams = new Dictionary<string, string>
                {
                    { "code", GenerateCode() },        // 验证码
                    { "expire", "5" }                  // 过期时间(分钟)
                }
            };

            // 使用配置的默认提供商发送
            var response = await _smsService.SendSmsAsync(smsRequest);

            if (response.IsSuccess)
            {
                _logger.LogInformation("短信发送成功，RequestId: {RequestId}, Provider: {Provider}",
                    response.RequestId, response.Provider);

                return Ok(new {
                    success = true,
                    requestId = response.RequestId,
                    provider = response.Provider,
                    message = "验证码发送成功"
                });
            }
            else
            {
                _logger.LogWarning("短信发送失败: {ErrorCode} - {ErrorMessage}",
                    response.StandardErrorCode, response.FriendlyErrorMessage);

                return BadRequest(new {
                    success = false,
                    errorCode = response.StandardErrorCode.ToString(),
                    errorMessage = response.FriendlyErrorMessage,
                    isRetryable = response.IsRetryable,
                    provider = response.Provider
                });
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "发送验证码时发生异常");
            return StatusCode(500, new {
                success = false,
                message = "系统异常，请稍后重试"
            });
        }
    }

    private string GenerateCode()
    {
        return new Random().Next(100000, 999999).ToString();
    }
}

public class SendCodeRequest
{
    public string PhoneNumber { get; set; }
}
```

### 指定提供商发送

```csharp
[HttpPost("send-with-provider")]
public async Task<IActionResult> SendWithSpecificProvider([FromBody] SendWithProviderRequest request)
{
    var smsRequest = new SmsRequest
    {
        PhoneNumber = request.PhoneNumber,
        TemplateId = request.TemplateId,
        SignName = request.SignName,
        TemplateParams = request.TemplateParams
    };

    // 方式1: 字符串指定提供商
    var response1 = await _smsService.SendSmsAsync(smsRequest, "Aliyun");
    var response2 = await _smsService.SendSmsAsync(smsRequest, "Tencent");

    // 方式2: 枚举指定提供商（类型安全，推荐）
    var response3 = await _smsService.SendSmsAsync(smsRequest, SmsProvider.Aliyun);
    var response4 = await _smsService.SendSmsAsync(smsRequest, SmsProvider.Tencent);

    return Ok(new { message = "发送完成" });
}
```

## 🔧 高级功能

### 故障转移机制

当启用 `EnableFailover = true` 时，如果默认提供商发送失败，系统会自动按照 `ProviderPriority` 的顺序尝试其他提供商：

```json
{
  "Sms": {
    "DefaultProvider": "Aliyun",
    "EnableFailover": true,
    "ProviderPriority": ["Aliyun", "Tencent"]
  }
}
```

### 智能错误处理和重试策略

```csharp
[HttpPost("send-with-retry")]
public async Task<IActionResult> SendWithRetry([FromBody] SendCodeRequest request)
{
    var smsRequest = new SmsRequest
    {
        PhoneNumber = request.PhoneNumber,
        TemplateId = "SMS_VERIFICATION",
        SignName = "您的应用",
        TemplateParams = new Dictionary<string, string>
        {
            { "code", GenerateCode() },
            { "expire", "5" }
        }
    };

    var response = await _smsService.SendSmsAsync(smsRequest);

    // 智能重试逻辑
    var retryCount = 0;
    var maxRetries = 3;

    while (!response.IsSuccess && response.IsRetryable && retryCount < maxRetries)
    {
        // 根据错误类型选择合适的延迟时间
        var delay = response.StandardErrorCode switch
        {
            StandardErrorCode.RateLimitExceeded => TimeSpan.FromMinutes(1),
            StandardErrorCode.NetworkError => TimeSpan.FromSeconds(5),
            StandardErrorCode.ProviderInternalError => TimeSpan.FromSeconds(10),
            _ => TimeSpan.FromSeconds(3)
        };

        _logger.LogInformation("重试发送短信，第{RetryCount}次，延迟{Delay}秒",
            retryCount + 1, delay.TotalSeconds);

        await Task.Delay(delay);
        retryCount++;

        response = await _smsService.SendSmsAsync(smsRequest);
    }

    if (response.IsSuccess)
    {
        return Ok(new {
            success = true,
            provider = response.Provider,
            retryCount = retryCount,
            message = retryCount > 0 ? $"重试{retryCount}次后发送成功" : "发送成功"
        });
    }
    else
    {
        return BadRequest(new {
            success = false,
            error = response.FriendlyErrorMessage,
            retryCount = retryCount,
            isRetryable = response.IsRetryable
        });
    }
}
```

## 📈 下一步

恭喜！您已经掌握了PolySms的基本使用。接下来可以：

1. **深入学习**：查看 [配置说明](配置说明.md) 了解更多配置选项
2. **企业级部署**：参考 [自定义配置文件指南](自定义配置文件使用指南.md)
3. **架构理解**：阅读 [架构设计](架构设计.md) 了解轻量级设计原理
4. **问题排查**：参考 [所有文档](INDEX.md) 解决具体问题

如有任何问题，欢迎在GitHub Issues中提问！